##' Draw a scatter plot
##'
##' This function creates a scatter plot with two numeric
##' variables. It supports colors and sizes generated by
##' \code{\link{qdata}}. When the sizes are not the same, a scatter
##' plot becomes what is called the ``bubble chart''.
##'
##' All the common interactions like brushing and deleting are
##' documented in \code{\link{common_key_press}}.
##'
##' In the identify mode, the plot will show the row id(s) of the
##' identified point(s) as well as \code{x} and \code{y} values.
##'
##' Arrow keys are used in scatter plots for interactions: without the
##' \code{Shift} key, \code{Up} and \code{Down} will increase/decrease
##' the sizes of points; with the \code{Shift} key being pressed,
##' \code{Up}, \code{Down}, \code{Left} and \code{Right} will move the
##' (background of) plot to the corresponding direction.
##'
##' Mouse wheel is used to zoom in and zoom out the plot. Together
##' with keyboard interactions, this will enable us to see details in
##' data.
##' @param x the name of the x variable
##' @param y the name of the y variable (if missing, \code{x} will be
##' plotted against its indices, i.e., \code{y} will become \code{x}
##' and \code{x} will be indices)
##' @inheritParams qbar
##' @param asp aspect ratio (ratio of the physical height of a plot to
##' its width; unlike other R graphics systems, this will \emph{not}
##' affect the ranges of axes)
##' @return A scatter plot
##' @author Heike Hofmann, Di Cook, Yihui Xie
##' @note Using more than one color (including border colors) can lead
##' to serious speed issues; this plot is fastest when we only use a
##' single color and a single size. As the number of unique colors
##' increases, the plotting can be slower based on a same
##' dataset. Using more than one size is also slower than using a
##' single size for all points; the internal painting functions are
##' different for the two cases (\code{\link[qtpaint]{qdrawCircle}}
##' for the former, and \code{\link[qtpaint]{qdrawGlyph}} for the
##' latter).
##' @export
##' @example inst/examples/qscatter-ex.R
qscatter =
    function(x, y, data = last_data(), main = '', xlim = NULL, ylim = NULL,
             xlab = NULL, ylab = NULL, asp = 1) {

    data = check_data(data)
    b = brush(data)
    z = as.list(match.call()[-1])

    ## initialize meta
    meta =
        Scat.meta$new(xvar = as.character(z$x), yvar = as.character(z$y),
                      alpha = 1, main = main, asp = asp, minor = 'xy',
                      samesize = diff(range(data$.size, na.rm=TRUE, finite=TRUE)) < 1e-7)

    ## set default xlab/ylab if not provided
    if (is.null(xlab)) meta$xlab = meta$xvar
    if (is.null(ylab)) meta$ylab = meta$yvar

    ## reorder the points according to color/border for drawing speed
    compute_order = function() {
        ord = order(data$.color, data$.border)  # the ideal order to draw
        names(ord) = seq(nrow(data))  # orignal order is in names
        meta$order = ord
    }
    compute_order()

    ## compute coordinates/axes-related stuff
    compute_coords = function() {
        if (is.null(z$y)) {
            meta$yvar = meta$xvar  # when y is missing, make it x
            meta$xvar = 'index'; meta$x = seq(sum(idx))
        } else {
            meta$x = data[meta$order, meta$xvar]
        }
        meta$y = data[meta$order, meta$yvar]
        idx = visible(data)[meta$order]
        meta$xat = axis_loc(meta$x[idx]); meta$yat = axis_loc(meta$y[idx])
        meta$xlabels = format(meta$xat); meta$ylabels = format(meta$yat)
        meta$xlab = if (is.null(xlab)) meta$xvar else xlab
        meta$ylab = if (is.null(ylab)) meta$yvar else ylab
        r =
            cbind(if (is.null(xlim))
                  range(meta$x[idx], na.rm = TRUE, finite = TRUE) else xlim,
                  if (is.null(ylim))
                  range(meta$y[idx], na.rm = TRUE, finite = TRUE) else ylim)
        meta$limits = extend_ranges(r)
    }
    compute_coords()

    ## aesthetics (colors)
    compute_aes = function() {
        idx = !visible(data)[meta$order]
        meta$color = data$.color[meta$order]; meta$border = data$.border[meta$order]
        meta$color[idx] = NA; meta$border[idx] = NA
        meta$size = data$.size[meta$order]; meta$size[idx] = NA
    }
    compute_aes()

    ## initialize brush size (1/15 of the layer size)
    meta$brush.size = c(1, -1) * apply(meta$limits, 2, diff) / 15

    ## draw points
    main_draw = function(layer, painter) {
        if (meta$samesize) {
            qdrawGlyph(painter, qglyphCircle(r = data$.size[1]), meta$x, meta$y,
                       stroke = meta$border, fill = meta$color)
        } else {
            qdrawCircle(painter, meta$x, meta$y, r = meta$size,
                        stroke = meta$border, fill = meta$color)
        }
    }

    ## draw brushed points
    brush_draw = function(layer, painter) {
        if (b$identify) return()
        idx = visible(data) & selected(data)
        if (any(idx)) {
            if (meta$samesize) {
                qdrawGlyph(painter, qglyphCircle(r = b$size * meta$size[1]),
                           data[idx, meta$xvar], data[idx, meta$yvar],
                           stroke = b$color, fill = b$color)
            } else {
                qdrawCircle(painter, data[idx, meta$xvar], data[idx, meta$yvar],
                            r = b$size * data$.size[idx],
                            stroke = b$color, fill = b$color)
            }
        }
        draw_brush(layer, painter, data, meta)
    }

    ## events
    brush_mouse_press = function(layer, event) {
        common_mouse_press(layer, event, data, meta)
    }
    brush_mouse_move = function(layer, event) {
        rect = qrect(update_brush_size(meta, event))
        hits = layer$locate(rect) + 1
        if (length(hits)) {
            hits = intersect(meta$order[as.character(hits)],  which(visible(data)))
        }
        selected(data) = mode_selection(selected(data), hits, mode = b$mode)
        common_mouse_move(layer, event, data, meta)
    }
    brush_mouse_release = function(layer, event) {
        brush_mouse_move(layer, event)
        common_mouse_release(layer, event, data, meta)
    }
    key_press = function(layer, event) {
        common_key_press(layer, event, data, meta)
        shift = event$modifiers() == Qt$Qt$ShiftModifier
        if (shift && length(i <- which(match_key(c('Left', 'Right', 'Up', 'Down'))))) {
            j = c(1, 1, 2, 2)[i]; k = c(1, -1, -1, 1)[i]
            meta$limits[, j] = extend_ranges(meta$limits[, j], k * c(1, -1) * 0.02)
        } else if (length(i <- which(match_key(c('Up', 'Down'))))) {
            ## change size
            data$.size = pmax(0.1, c(1.1, 0.9)[i] * data$.size)
        }
    }
    key_release = function(layer, event) {
        common_key_release(layer, event, data, meta)
    }
    mouse_wheel = function(layer, event) {
        pos = as.numeric(event$pos())
        lim = meta$limits
        p = (pos - lim[1, ]) / (lim[2, ] - lim[1, ])  # proportions to left/bottom
        meta$limits =
            extend_ranges(meta$limits,
                          -sign(event$delta()) * 0.1 * c(p[1], 1 - p[1], p[2], 1 - p[2]))
    }
    identify_hover = function(layer, event) {
        if (!b$identify) return()
        b$cursor = 2L
        meta$pos = as.numeric(event$pos())
        hits = layer$locate(identify_rect(meta)) + 1
        meta$identified = intersect(meta$order[as.character(hits)], which(visible(data)))
        qupdate(layer.identify)
    }
    identify_draw = function(layer, painter) {
        if (!b$identify || !length(idx <- meta$identified)) return()
        meta$identify.labels =
            sprintf('row id: %s\n%s: %s\n%s: %s',
                    paste(rownames(data)[idx], collapse = ', '),
                    meta$xvar, paste(data[idx, meta$xvar], collapse = ', '),
                    meta$yvar, paste(data[idx, meta$yvar], collapse = ', '))
        draw_identify(layer, painter, data, meta)
        if (meta$samesize) {
            qdrawGlyph(painter, qglyphCircle(r = 2 * b$size * data$.size[1]),
                       data[idx, meta$xvar], data[idx, meta$yvar],
                       stroke = b$color, fill = NA)
        } else {
            qdrawCircle(painter, data[idx, meta$xvar], data[idx, meta$yvar],
                        r = b$size * meta$size, stroke = b$color, fill = NA)
        }
    }

    ## create layers
    scene = qscene()
    layer.root = qlayer(scene)
    layer.main =
        qlayer(paintFun = main_draw,
               mousePressFun = brush_mouse_press, mouseReleaseFun = brush_mouse_release,
               mouseMove = brush_mouse_move, hoverMoveFun = identify_hover,
               keyPressFun = key_press, keyReleaseFun = key_release,
               wheelFun = mouse_wheel,
               limits = qrect(meta$limits), clip = TRUE)
    layer.brush = qlayer(paintFun = brush_draw, limits = qrect(meta$limits))
    layer.identify = qlayer(paintFun = identify_draw, limits = qrect(meta$limits))
    layer.title = qmtext(meta = meta, side = 3)
    layer.xlab = qmtext(meta = meta, side = 1)
    layer.ylab = qmtext(meta = meta, side = 2)
    layer.xaxis = qaxis(meta = meta, side = 1)
    layer.yaxis = qaxis(meta = meta, side = 2)
    layer.grid = qgrid(meta = meta)
    layer.root[0, 2] = layer.title
    layer.root[2, 2] = layer.xaxis
    layer.root[3, 2] = layer.xlab
    layer.root[1, 1] = layer.yaxis
    layer.root[1, 0] = layer.ylab
    layer.root[1, 2] = layer.grid
    layer.root[1, 2] = layer.main
    layer.root[1, 2] = layer.brush
    layer.root[1, 2] = layer.identify
    layer.root[1, 3] = qlayer()

    ## set sizes of layers (arrange the layout)
    set_layout = function() {
        fix_dimension(layer.root,
                      row = list(id = c(0, 2, 3), value = c(prefer_height(meta$main),
                                                  prefer_height(meta$xlabels),
                                                  prefer_height(meta$xlab))),
                      column = list(id = c(1, 0, 3), value = c(prefer_width(meta$ylabels),
                                                     prefer_width(meta$ylab, FALSE),
                                                     10)))
    }
    set_layout()

    ## layout is dynamic (listen to changes in xlab/ylab/xlabels/ylabels...)
    meta$mainChanged$connect(set_layout)
    meta$xlabChanged$connect(set_layout); meta$ylabChanged$connect(set_layout)
    meta$xlabelsChanged$connect(set_layout); meta$ylabelsChanged$connect(set_layout)

    ## finally create the view and set window title
    view = qplotView(scene = scene)
    view$setWindowTitle(paste("Scatterplot:", meta$xvar, meta$yvar))
    meta$xvarChanged$connect(function() {
        view$setWindowTitle(paste("Scatterplot:", meta$xvar, meta$yvar))
    })
    if (!is.null(asp)) view$resize(480, 480 * asp)  # aspect ratio

    ## listeners on the data (which column updates which layer(s))
    d.idx = add_listener(data, function(i, j) {
        idx = which(j == c(meta$xvar, meta$yvar, '.brushed', '.color', '.border'))
        if (length(idx) < 1) {
            compute_coords(); compute_aes()
            meta$samesize = diff(range(data$.size, na.rm = TRUE, finite = TRUE)) < 1e-7
            qupdate(layer.grid); qupdate(layer.xaxis); qupdate(layer.yaxis)
            layer.main$invalidateIndex(); qupdate(layer.main)
            return()
        } else idx = c(1, 1, 2, 3, 3)[idx]
        switch(idx, compute_coords(), qupdate(layer.brush), {
            compute_order(); compute_aes(); qupdate(layer.main)
        })
    })

    ## when layer is destroyed, remove the listener from data
    qconnect(layer.main, 'destroyed', function(x) {
        ## b$colorChanged$disconnect(b.idx)
        remove_listener(data, d.idx)
    })

    ## when b$cursor is changed, update cursor on screen
    b$cursorChanged$connect(function() {
        set_cursor(view, b$cursor)
    })

    ## these layers have the same limits from meta$limits
    sync_limits(meta, layer.main, layer.brush, layer.identify)

    ## simulate brushing
    meta$manual.brush = function(pos) {
        brush_mouse_move(layer = layer.main, event = list(pos = function() pos))
    }

    ## attach meta to the returned value (for post-processing or debugging)
    attr(view, 'meta') = meta
    view
}

Scat.meta =
    setRefClass("Scat_meta",
                fields = properties(c(

                Common.meta,

                list(xvar = 'character', yvar = 'character', order = 'numeric',
                     x = 'numeric', y = 'numeric',
                     breaks = 'numeric', asp = 'numeric', samesize = 'logical')

                )))

## order is for keeping track of the original order of data
