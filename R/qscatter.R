##' Draw a scatter plot
##'
##' This function creates a scatter plot with two numeric
##' variables. It supports colors and sizes generated by
##' \code{\link{qdata}}. When the sizes are not the same, a scatter
##' plot becomes what is called the ``bubble chart''.
##'
##' All the common interactions like brushing and deleting are
##' documented in \code{\link{common_key_press}}.
##'
##' In the identify mode, the plot will show the row id(s) of the
##' identified point(s) as well as \code{x} and \code{y} values.
##'
##' Arrow keys are used in scatter plots for interactions: without the
##' \code{Shift} key, \code{Up} and \code{Down} will increase/decrease
##' the sizes of points; with the \code{Shift} key being pressed,
##' \code{Up}, \code{Down}, \code{Left} and \code{Right} will move the
##' points to the corresponding direction.
##'
##' Mouse wheel is used to zoom in and zoom out the plot. Together
##' with keyboard interactions, this will enable us to see details in
##' data.
##' @param x the name of the x variable
##' @param y the name of the y variable (if missing, \code{x} will be
##' plotted against its indices, i.e., \code{y} will become \code{x}
##' and \code{x} will be indices)
##' @inheritParams qbar
##' @param asp aspect ratio (\code{NULL} means to use the data ranges
##' directly, and a positive value of the aspect ratio will change the
##' limits of one of the two axes); the implementation is not perfect
##' yet, since resizing the plotting window will change the aspect
##' ratio (different to other R graphics systems)
##' @return A scatter plot
##' @author Heike Hofmann, Di Cook, Yihui Xie
##' @note Using more than one color (including border colors) can lead
##' to serious speed issues; this plot is fastest when we only use a
##' single color and a single size. As the number of unique colors
##' increases, the plotting can be slower based on a same
##' dataset. Using more than one size is also slower than using a
##' single size for all points; the internal painting functions are
##' different for the two cases (\code{\link[qtpaint]{qdrawCircle}}
##' for the former, and \code{\link[qtpaint]{qdrawGlyph}} for the
##' latter).
##' @export
##' @example inst/examples/qscatter-ex.R
qscatter =
    function(x, y, data = last_data(), main = '', xlim = NULL, ylim = NULL,
             xlab = NULL, ylab = NULL, asp = NULL) {

    data = check_data(data)
    b = brush(data)
    z = as.list(match.call()[-1])
    meta =
        Scat.meta$new(xvar = as.character(z$x), yvar = as.character(z$y),
                      alpha = 1, main = main, asp = asp,
                      samesize = diff(range(data$.size, na.rm=TRUE, finite=TRUE)) < 1e-7)
    if (is.null(xlab)) meta$xlab = meta$xvar
    if (is.null(ylab)) meta$ylab = meta$yvar
    compute_order = function() {
        ord = order(data$.color, data$.border)  # the ideal order to draw
        names(ord) = seq(nrow(data))  # orignal order is in names
        meta$order = ord
    }
    compute_order()
    compute_coords = function() {
        if (is.null(z$y)) {
            meta$yvar = meta$xvar  # when y is missing, make it x
            meta$xvar = 'index'; meta$x = seq(sum(idx))
        } else {
            meta$x = data[meta$order, meta$xvar]
        }
        meta$y = data[meta$order, meta$yvar]
        idx = visible(data)[meta$order]
        meta$xat = axis_loc(meta$x[idx]); meta$yat = axis_loc(meta$y[idx])
        meta$xlabels = format(meta$xat); meta$ylabels = format(meta$yat)
        meta$xlab = if (is.null(xlab)) meta$xvar else xlab
        meta$ylab = if (is.null(ylab)) meta$yvar else ylab
        r =
            cbind(if (is.null(xlim))
                  range(meta$x[idx], na.rm = TRUE, finite = TRUE) else xlim,
                  if (is.null(ylim))
                  range(meta$y[idx], na.rm = TRUE, finite = TRUE) else ylim)
        if (!is.null(asp)) {
            asp = asp / 1.5  # 1.5 = 600/400 from the default window size
            r = if (asp * (rx <- abs(r[2, 1] - r[1, 1])) > (ry <- abs(r[2, 2] - r[1, 2]))) {
                ## expand ylim
                cbind(r[, 1], extend_ranges(r[, 2], (rx * asp / ry - 1) / 2))
            } else {
                ## DOUBLE CHECK HERE
                cbind(extend_ranges(r[, 1], (ry / (rx * asp) - 1) / 2), r[, 2])
            }
        }
        meta$limits = extend_ranges(r)
    }
    compute_coords()
    compute_aes = function() {
        idx = !visible(data)[meta$order]
        meta$color = data$.color[meta$order]; meta$border = data$.border[meta$order]
        meta$color[idx] = NA; meta$border[idx] = NA
        meta$size = data$.size[meta$order]; meta$size[idx] = NA
    }
    compute_aes()
    meta$brush.size = c(1, -1) * apply(meta$limits, 2, diff) / 15
    main_draw = function(layer, painter) {
        if (meta$samesize) {
            qdrawGlyph(painter, qglyphCircle(r = data$.size[1]), meta$x, meta$y,
                       stroke = meta$border, fill = meta$color)
        } else {
            qdrawCircle(painter, meta$x, meta$y, r = meta$size,
                        stroke = meta$border, fill = meta$color)
        }
    }
    brush_draw = function(layer, painter) {
        if (b$identify) return()
        idx = visible(data) & selected(data)
        if (any(idx)) {
            if (meta$samesize) {
                qdrawGlyph(painter, qglyphCircle(r = b$size * meta$size[1]),
                           data[idx, meta$xvar], data[idx, meta$yvar],
                           stroke = b$color, fill = b$color)
            } else {
                qdrawCircle(painter, data[idx, meta$xvar], data[idx, meta$yvar],
                            r = b$size * data$.size[idx],
                            stroke = b$color, fill = b$color)
            }
        }
        draw_brush(layer, painter, data, meta)
    }
    brush_mouse_press = function(layer, event) {
        common_mouse_press(layer, event, data, meta)
    }
    brush_mouse_move = function(layer, event) {
        rect = qrect(update_brush_size(meta, event))
        hits = layer$locate(rect) + 1
        if (length(hits)) {
            hits = intersect(meta$order[as.character(hits)],  which(visible(data)))
        }
        selected(data) = mode_selection(selected(data), hits, mode = b$mode)
        common_mouse_move(layer, event, data, meta)
    }
    brush_mouse_release = function(layer, event) {
        brush_mouse_move(layer, event)
        common_mouse_release(layer, event, data, meta)
    }
    key_press = function(layer, event) {
        common_key_press(layer, event, data, meta)
        shift = event$modifiers() == Qt$Qt$ShiftModifier
        if (shift && length(i <- which(match_key(c('Left', 'Right', 'Up', 'Down'))))) {
            j = c(1, 1, 2, 2)[i]; k = c(1, -1, -1, 1)[i]
            meta$limits[, j] = extend_ranges(meta$limits[, j], k * c(1, -1) * 0.02)
        } else if (length(i <- which(match_key(c('Up', 'Down'))))) {
            ## change size
            data$.size = pmax(0.1, c(1.1, 0.9)[i] * data$.size)
        }
    }
    key_release = function(layer, event) {
        common_key_release(layer, event, data, meta)
    }
    mouse_wheel = function(layer, event) {
        meta$limits = extend_ranges(meta$limits, -sign(event$delta()) * 0.05)
    }
    identify_hover = function(layer, event) {
        if (!b$identify) return()
        b$cursor = 2L
        meta$pos = as.numeric(event$pos())
        hits = layer$locate(identify_rect(meta)) + 1
        meta$identified = intersect(meta$order[as.character(hits)], which(visible(data)))
        qupdate(layer.identify)
    }
    identify_draw = function(layer, painter) {
        if (!b$identify || !length(idx <- meta$identified)) return()
        meta$identify.labels =
            sprintf('row id: %s\n%s: %s\n%s: %s',
                    paste(rownames(data)[idx], collapse = ', '),
                    meta$xvar, paste(data[idx, meta$xvar], collapse = ', '),
                    meta$yvar, paste(data[idx, meta$yvar], collapse = ', '))
        draw_identify(layer, painter, data, meta)
        if (meta$samesize) {
            qdrawGlyph(painter, qglyphCircle(r = 2 * b$size * data$.size[1]),
                       data[idx, meta$xvar], data[idx, meta$yvar],
                       stroke = b$color, fill = NA)
        } else {
            qdrawCircle(painter, data[idx, meta$xvar], data[idx, meta$yvar],
                        r = b$size * meta$size, stroke = b$color, fill = NA)
        }
    }
    scene = qscene()
    layer.root = qlayer(scene)
    layer.main =
        qlayer(paintFun = main_draw,
               mousePressFun = brush_mouse_press, mouseReleaseFun = brush_mouse_release,
               mouseMove = brush_mouse_move, hoverMoveFun = identify_hover,
               keyPressFun = key_press, keyReleaseFun = key_release,
               wheelFun = mouse_wheel,
               limits = qrect(meta$limits), clip = TRUE)
    layer.brush = qlayer(paintFun = brush_draw, limits = qrect(meta$limits))
    layer.identify = qlayer(paintFun = identify_draw, limits = qrect(meta$limits))
    layer.title = qmtext(meta = meta, side = 3)
    layer.xlab = qmtext(meta = meta, side = 1)
    layer.ylab = qmtext(meta = meta, side = 2)
    layer.xaxis = qaxis(meta = meta, side = 1)
    layer.yaxis = qaxis(meta = meta, side = 2)
    layer.grid = qgrid(meta = meta, minor = 'xy')
    layer.root[0, 2] = layer.title
    layer.root[2, 2] = layer.xaxis
    layer.root[3, 2] = layer.xlab
    layer.root[1, 1] = layer.yaxis
    layer.root[1, 0] = layer.ylab
    layer.root[1, 2] = layer.grid
    layer.root[1, 2] = layer.main
    layer.root[1, 2] = layer.brush
    layer.root[1, 2] = layer.identify
    layer.root[1, 3] = qlayer()
    layout = layer.root$gridLayout()
    layout$setRowPreferredHeight(0, prefer_height(meta$main))
    layout$setRowPreferredHeight(2, prefer_height(meta$xlabels))
    layout$setRowPreferredHeight(3, prefer_height(meta$xlab))
    layout$setColumnPreferredWidth(0, prefer_width(meta$ylab, FALSE))
    layout$setColumnPreferredWidth(1, prefer_width(meta$ylabels))
    layout$setColumnMaximumWidth(3, 10)
    layout$setRowStretchFactor(0, 0)
    layout$setRowStretchFactor(2, 0)
    layout$setRowStretchFactor(3, 0)
    layout$setColumnStretchFactor(0, 0)
    layout$setColumnStretchFactor(1, 0)
    view = qplotView(scene = scene)
    view$setWindowTitle(paste("Scatterplot:", meta$xvar, meta$yvar))
    meta$xvarChanged$connect(function() {
        view$setWindowTitle(paste("Scatterplot:", meta$xvar, meta$yvar))
    })
    d.idx = add_listener(data, function(i, j) {
        idx = which(j == c(meta$xvar, meta$yvar, '.brushed', '.color', '.border'))
        if (length(idx) < 1) {
            compute_coords(); compute_aes()
            meta$samesize = diff(range(data$.size, na.rm = TRUE, finite = TRUE)) < 1e-7
            qupdate(layer.grid); qupdate(layer.xaxis); qupdate(layer.yaxis)
            layer.main$invalidateIndex(); qupdate(layer.main)
            return()
        } else idx = c(1, 1, 2, 3, 3)[idx]
        switch(idx, compute_coords(), qupdate(layer.brush), {
            compute_order(); compute_aes(); qupdate(layer.main)
        })
    })
    qconnect(layer.main, 'destroyed', function(x) {
        ## b$colorChanged$disconnect(b.idx)
        remove_listener(data, d.idx)
    })

    b$cursorChanged$connect(function() {
        set_cursor(view, b$cursor)
    })
    sync_limits(meta, layer.main, layer.brush, layer.identify)  # sync limits
    meta$manual.brush = function(pos) {
        brush_mouse_move(layer = layer.main, event = list(pos = function() pos))
    }
    attr(view, 'meta') = meta
    view
}

Scat.meta =
    setRefClass("Scat_meta", fields =
                signalingFields(list(xvar = 'character', yvar = 'character',
                                     alpha = 'numeric', order = 'numeric',
                                     x = 'numeric', y = 'numeric',
                                     xat = 'numeric', yat = 'numeric',
                                     xlab = 'character', ylab = 'character',
                                     xlabels = 'character', ylabels = 'character',
                                     breaks = 'numeric', limits = 'matrix',
                                     border = 'character', color = 'character',
                                     start = 'numeric', pos = 'numeric',
                                     brush.move = 'logical', brush.size = 'numeric',
                                     main = 'character', asp = 'numeric',
                                     size = 'numeric', samesize = 'logical',
                                     identified = 'numeric', identify.labels = 'character',
                                     manual.brush = 'function')))

## order is for keeping track of the original order of data
